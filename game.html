<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bounce - Nokia Classic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .game-container {
            background: #000;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
        }

        canvas {
            display: block;
            border: 3px solid #333;
            border-radius: 5px;
        }

        .controls {
            color: #fff;
            text-align: center;
            margin-top: 20px;
            font-size: 14px;
        }

        .controls span {
            background: #333;
            padding: 5px 15px;
            border-radius: 5px;
            margin: 0 5px;
        }

        h1 {
            color: #ff4444;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .stats {
            color: #fff;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #111;
            border-radius: 5px 5px 0 0;
            font-size: 16px;
        }

        .mobile-controls {
            display: none;
            margin-top: 20px;
            gap: 10px;
        }

        .mobile-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            touch-action: manipulation;
        }

        .btn-left,
        .btn-right {
            background: linear-gradient(145deg, #444, #222);
            color: #fff;
        }

        .btn-jump {
            background: linear-gradient(145deg, #ff6666, #cc0000);
            color: #fff;
            width: 100px;
            height: 100px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                align-items: center;
            }

            .controls {
                display: none;
            }
        }
    </style>
</head>

<body>
    <h1>üî¥ BOUNCE</h1>
    <div class="game-container">
        <div class="stats">
            <span>Level: <span id="level">1</span></span>
            <span>Rings: <span id="rings">0</span>/<span id="totalRings">0</span></span>
            <span>Lives: <span id="lives">3</span></span>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
    </div>
    <div class="controls">
        <span>‚Üê‚Üí Move</span>
        <span>‚Üë / Space Jump</span>
        <span>R Restart</span>
    </div>
    <div class="mobile-controls">
        <button class="mobile-btn btn-left" id="btnLeft">‚óÄ</button>
        <button class="mobile-btn btn-jump" id="btnJump">JUMP</button>
        <button class="mobile-btn btn-right" id="btnRight">‚ñ∂</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = 'playing'; // playing, won, lost
        let currentLevel = 1;
        let lives = 3;

        // Ball properties
        const ball = {
            x: 100,
            y: 300,
            radius: 20,
            baseRadius: 20,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpForce: -15,
            onGround: false,
            inflated: true,
            color: '#ff4444'
        };

        // Physics
        const gravity = 0.6;
        const friction = 0.8;
        const bounce = 0.3;

        // Camera
        let cameraX = 0;

        // Input
        const keys = {
            left: false,
            right: false,
            up: false
        };

        // Level elements
        let platforms = [];
        let rings = [];
        let spikes = [];
        let inflators = [];
        let deflators = [];
        let checkpoints = [];
        let exitDoor = null;
        let collectedRings = 0;
        let lastCheckpoint = { x: 100, y: 300 };

        // Particles
        let particles = [];

        // Level definitions
        const levels = [
            // Level 1 - Tutorial
            {
                platforms: [
                    { x: 0, y: 450, width: 400, height: 50 },
                    { x: 450, y: 400, width: 200, height: 50 },
                    { x: 700, y: 350, width: 150, height: 50 },
                    { x: 900, y: 300, width: 200, height: 50 },
                    { x: 1150, y: 350, width: 150, height: 50 },
                    { x: 1350, y: 400, width: 200, height: 50 },
                    { x: 1600, y: 450, width: 400, height: 50 },
                ],
                rings: [
                    { x: 200, y: 400 }, { x: 250, y: 400 }, { x: 300, y: 400 },
                    { x: 520, y: 350 }, { x: 580, y: 350 },
                    { x: 760, y: 300 },
                    { x: 980, y: 250 }, { x: 1040, y: 250 },
                    { x: 1420, y: 350 },
                    { x: 1700, y: 400 }, { x: 1750, y: 400 }, { x: 1800, y: 400 },
                ],
                spikes: [
                    { x: 650, y: 430, width: 40, height: 20 }
                ],
                inflators: [],
                deflators: [],
                checkpoints: [
                    { x: 1000, y: 260 }
                ],
                exit: { x: 1900, y: 390 },
                startX: 100,
                startY: 400
            },
            // Level 2 - Spikes
            {
                platforms: [
                    { x: 0, y: 450, width: 300, height: 50 },
                    { x: 350, y: 450, width: 100, height: 50 },
                    { x: 500, y: 450, width: 100, height: 50 },
                    { x: 650, y: 400, width: 150, height: 50 },
                    { x: 850, y: 350, width: 100, height: 50 },
                    { x: 1000, y: 300, width: 150, height: 50 },
                    { x: 1200, y: 350, width: 100, height: 50 },
                    { x: 1350, y: 400, width: 150, height: 50 },
                    { x: 1550, y: 450, width: 300, height: 50 },
                ],
                rings: [
                    { x: 150, y: 400 }, { x: 200, y: 380 }, { x: 250, y: 400 },
                    { x: 390, y: 400 }, { x: 540, y: 400 },
                    { x: 710, y: 350 },
                    { x: 890, y: 300 },
                    { x: 1060, y: 250 },
                    { x: 1240, y: 300 },
                    { x: 1410, y: 350 },
                    { x: 1650, y: 400 }, { x: 1700, y: 400 }, { x: 1750, y: 400 },
                ],
                spikes: [
                    { x: 300, y: 430, width: 40, height: 20 },
                    { x: 450, y: 430, width: 40, height: 20 },
                    { x: 600, y: 430, width: 40, height: 20 },
                    { x: 1150, y: 330, width: 40, height: 20 },
                    { x: 1500, y: 430, width: 40, height: 20 },
                ],
                inflators: [],
                deflators: [],
                checkpoints: [
                    { x: 1050, y: 260 }
                ],
                exit: { x: 1780, y: 390 },
                startX: 100,
                startY: 400
            },
            // Level 3 - Inflate/Deflate
            {
                platforms: [
                    { x: 0, y: 450, width: 300, height: 50 },
                    { x: 350, y: 400, width: 150, height: 50 },
                    { x: 350, y: 200, width: 150, height: 200, isTunnel: true },
                    { x: 550, y: 350, width: 100, height: 150 },
                    { x: 700, y: 300, width: 200, height: 200 },
                    { x: 950, y: 400, width: 200, height: 50 },
                    { x: 950, y: 200, width: 200, height: 200, isTunnel: true },
                    { x: 1200, y: 350, width: 150, height: 50 },
                    { x: 1400, y: 300, width: 100, height: 50 },
                    { x: 1550, y: 250, width: 100, height: 50 },
                    { x: 1700, y: 300, width: 100, height: 50 },
                    { x: 1850, y: 400, width: 200, height: 50 },
                ],
                rings: [
                    { x: 150, y: 400 }, { x: 200, y: 400 },
                    { x: 410, y: 350 }, { x: 450, y: 350 },
                    { x: 590, y: 300 },
                    { x: 780, y: 250 }, { x: 840, y: 250 },
                    { x: 1030, y: 350 }, { x: 1090, y: 350 },
                    { x: 1260, y: 300 },
                    { x: 1440, y: 250 },
                    { x: 1590, y: 200 },
                    { x: 1740, y: 250 },
                    { x: 1920, y: 350 }, { x: 1970, y: 350 },
                ],
                spikes: [
                    { x: 650, y: 280, width: 40, height: 20 },
                    { x: 1150, y: 380, width: 40, height: 20 },
                ],
                inflators: [
                    { x: 600, y: 320 },
                    { x: 1250, y: 320 },
                ],
                deflators: [
                    { x: 320, y: 380 },
                    { x: 920, y: 380 },
                ],
                checkpoints: [
                    { x: 800, y: 260 },
                    { x: 1600, y: 210 }
                ],
                exit: { x: 2000, y: 340 },
                startX: 100,
                startY: 400
            }
        ];

        function loadLevel(levelNum) {
            const level = levels[levelNum - 1];
            if (!level) {
                gameState = 'won';
                return;
            }

            platforms = level.platforms.map(p => ({ ...p }));
            rings = level.rings.map(r => ({ ...r, collected: false, radius: 15 }));
            spikes = level.spikes.map(s => ({ ...s }));
            inflators = level.inflators.map(i => ({ ...i, radius: 20 }));
            deflators = level.deflators.map(d => ({ ...d, radius: 20 }));
            checkpoints = level.checkpoints.map(c => ({ ...c, activated: false }));
            exitDoor = { ...level.exit, width: 40, height: 60 };

            ball.x = level.startX;
            ball.y = level.startY;
            ball.vx = 0;
            ball.vy = 0;
            ball.inflated = true;
            ball.radius = ball.baseRadius;

            lastCheckpoint = { x: level.startX, y: level.startY };
            collectedRings = 0;
            cameraX = 0;

            document.getElementById('level').textContent = levelNum;
            document.getElementById('totalRings').textContent = rings.length;
            updateRingDisplay();
        }

        function updateRingDisplay() {
            document.getElementById('rings').textContent = collectedRings;
            document.getElementById('lives').textContent = lives;
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    radius: Math.random() * 4 + 2,
                    color: color,
                    life: 1
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x - cameraX, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function update() {
            if (gameState !== 'playing') return;

            // Input handling
            if (keys.left) ball.vx = -ball.speed;
            else if (keys.right) ball.vx = ball.speed;
            else ball.vx *= friction;

            if (keys.up && ball.onGround) {
                ball.vy = ball.inflated ? ball.jumpForce : ball.jumpForce * 0.7;
                ball.onGround = false;
            }

            // Apply gravity
            ball.vy += gravity;

            // Move ball
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Platform collision
            ball.onGround = false;
            platforms.forEach(platform => {
                if (platform.isTunnel && ball.inflated) return; // Can't enter tunnels when inflated

                const collision = checkPlatformCollision(ball, platform);
                if (collision) {
                    if (collision === 'top') {
                        ball.y = platform.y - ball.radius;
                        ball.vy = 0;
                        ball.onGround = true;
                    } else if (collision === 'bottom') {
                        ball.y = platform.y + platform.height + ball.radius;
                        ball.vy = Math.abs(ball.vy) * bounce;
                    } else if (collision === 'left') {
                        ball.x = platform.x - ball.radius;
                        ball.vx = 0;
                    } else if (collision === 'right') {
                        ball.x = platform.x + platform.width + ball.radius;
                        ball.vx = 0;
                    }
                }
            });

            // Ring collection
            rings.forEach(ring => {
                if (!ring.collected) {
                    const dist = Math.hypot(ball.x - ring.x, ball.y - ring.y);
                    if (dist < ball.radius + ring.radius) {
                        ring.collected = true;
                        collectedRings++;
                        updateRingDisplay();
                        createParticles(ring.x, ring.y, '#ffff00', 15);
                    }
                }
            });

            // Spike collision
            spikes.forEach(spike => {
                if (checkSpikeCollision(ball, spike)) {
                    die();
                }
            });

            // Inflator collision
            inflators.forEach(inflator => {
                const dist = Math.hypot(ball.x - inflator.x, ball.y - inflator.y);
                if (dist < ball.radius + inflator.radius && !ball.inflated) {
                    ball.inflated = true;
                    ball.radius = ball.baseRadius;
                    createParticles(ball.x, ball.y, '#00ff00', 20);
                }
            });

            // Deflator collision
            deflators.forEach(deflator => {
                const dist = Math.hypot(ball.x - deflator.x, ball.y - deflator.y);
                if (dist < ball.radius + deflator.radius && ball.inflated) {
                    ball.inflated = false;
                    ball.radius = ball.baseRadius * 0.6;
                    createParticles(ball.x, ball.y, '#0088ff', 20);
                }
            });

            // Checkpoint collision
            checkpoints.forEach(checkpoint => {
                if (!checkpoint.activated) {
                    const dist = Math.hypot(ball.x - checkpoint.x, ball.y - checkpoint.y);
                    if (dist < ball.radius + 25) {
                        checkpoint.activated = true;
                        lastCheckpoint = { x: checkpoint.x, y: checkpoint.y };
                        createParticles(checkpoint.x, checkpoint.y, '#00ff88', 25);
                    }
                }
            });

            // Exit door
            if (collectedRings >= rings.length) {
                if (ball.x > exitDoor.x && ball.x < exitDoor.x + exitDoor.width &&
                    ball.y > exitDoor.y && ball.y < exitDoor.y + exitDoor.height) {
                    currentLevel++;
                    if (currentLevel > levels.length) {
                        gameState = 'won';
                    } else {
                        loadLevel(currentLevel);
                    }
                }
            }

            // Fall death
            if (ball.y > canvas.height + 100) {
                die();
            }

            // Camera follow
            const targetCameraX = ball.x - canvas.width / 3;
            cameraX += (targetCameraX - cameraX) * 0.1;
            if (cameraX < 0) cameraX = 0;

            // Update particles
            updateParticles();
        }

        function checkPlatformCollision(ball, platform) {
            const ballLeft = ball.x - ball.radius;
            const ballRight = ball.x + ball.radius;
            const ballTop = ball.y - ball.radius;
            const ballBottom = ball.y + ball.radius;

            const platLeft = platform.x;
            const platRight = platform.x + platform.width;
            const platTop = platform.y;
            const platBottom = platform.y + platform.height;

            if (ballRight > platLeft && ballLeft < platRight &&
                ballBottom > platTop && ballTop < platBottom) {

                const overlapLeft = ballRight - platLeft;
                const overlapRight = platRight - ballLeft;
                const overlapTop = ballBottom - platTop;
                const overlapBottom = platBottom - ballTop;

                const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                if (minOverlap === overlapTop && ball.vy > 0) return 'top';
                if (minOverlap === overlapBottom && ball.vy < 0) return 'bottom';
                if (minOverlap === overlapLeft) return 'left';
                if (minOverlap === overlapRight) return 'right';
            }
            return null;
        }

        function checkSpikeCollision(ball, spike) {
            return ball.x + ball.radius > spike.x &&
                ball.x - ball.radius < spike.x + spike.width &&
                ball.y + ball.radius > spike.y &&
                ball.y - ball.radius < spike.y + spike.height;
        }

        function die() {
            lives--;
            updateRingDisplay();
            createParticles(ball.x, ball.y, '#ff0000', 30);

            if (lives <= 0) {
                gameState = 'lost';
            } else {
                ball.x = lastCheckpoint.x;
                ball.y = lastCheckpoint.y;
                ball.vx = 0;
                ball.vy = 0;
                ball.inflated = true;
                ball.radius = ball.baseRadius;
            }
        }

        function draw() {
            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid background
            ctx.strokeStyle = '#2a2a4e';
            ctx.lineWidth = 1;
            for (let x = -cameraX % 50; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw platforms
            platforms.forEach(platform => {
                const x = platform.x - cameraX;
                if (x + platform.width < 0 || x > canvas.width) return;

                if (platform.isTunnel) {
                    ctx.fillStyle = '#2a4a2a';
                    ctx.strokeStyle = '#4a8a4a';
                } else {
                    ctx.fillStyle = '#3a3a5a';
                    ctx.strokeStyle = '#5a5a8a';
                }
                ctx.fillRect(x, platform.y, platform.width, platform.height);
                ctx.strokeRect(x, platform.y, platform.width, platform.height);

                // Platform pattern
                ctx.fillStyle = platform.isTunnel ? '#3a5a3a' : '#4a4a6a';
                for (let px = 0; px < platform.width; px += 20) {
                    for (let py = 0; py < platform.height; py += 20) {
                        if ((px + py) % 40 === 0) {
                            ctx.fillRect(x + px, platform.y + py, 10, 10);
                        }
                    }
                }
            });

            // Draw spikes
            spikes.forEach(spike => {
                const x = spike.x - cameraX;
                if (x + spike.width < 0 || x > canvas.width) return;

                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.moveTo(x, spike.y + spike.height);
                ctx.lineTo(x + spike.width / 2, spike.y);
                ctx.lineTo(x + spike.width, spike.y + spike.height);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#aa0000';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw rings
            rings.forEach(ring => {
                if (ring.collected) return;
                const x = ring.x - cameraX;
                if (x < -50 || x > canvas.width + 50) return;

                const pulse = Math.sin(Date.now() / 200) * 3;

                ctx.beginPath();
                ctx.arc(x, ring.y, ring.radius + pulse, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 4;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(x, ring.y, ring.radius - 5 + pulse, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw inflators
            inflators.forEach(inflator => {
                const x = inflator.x - cameraX;
                if (x < -50 || x > canvas.width + 50) return;

                ctx.beginPath();
                ctx.arc(x, inflator.y, inflator.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.strokeStyle = '#00aa00';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('+', x, inflator.y);
            });

            // Draw deflators
            deflators.forEach(deflator => {
                const x = deflator.x - cameraX;
                if (x < -50 || x > canvas.width + 50) return;

                ctx.beginPath();
                ctx.arc(x, deflator.y, deflator.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#0088ff';
                ctx.fill();
                ctx.strokeStyle = '#0055aa';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('-', x, deflator.y);
            });

            // Draw checkpoints
            checkpoints.forEach(checkpoint => {
                const x = checkpoint.x - cameraX;
                if (x < -50 || x > canvas.width + 50) return;

                ctx.beginPath();
                ctx.moveTo(x, checkpoint.y);
                ctx.lineTo(x, checkpoint.y - 40);
                ctx.strokeStyle = checkpoint.activated ? '#00ff88' : '#888888';
                ctx.lineWidth = 4;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x, checkpoint.y - 40);
                ctx.lineTo(x + 25, checkpoint.y - 30);
                ctx.lineTo(x, checkpoint.y - 20);
                ctx.closePath();
                ctx.fillStyle = checkpoint.activated ? '#00ff88' : '#888888';
                ctx.fill();
            });

            // Draw exit door
            if (exitDoor) {
                const x = exitDoor.x - cameraX;
                const isOpen = collectedRings >= rings.length;

                ctx.fillStyle = isOpen ? '#00ff00' : '#444444';
                ctx.fillRect(x, exitDoor.y, exitDoor.width, exitDoor.height);

                ctx.strokeStyle = isOpen ? '#00aa00' : '#666666';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, exitDoor.y, exitDoor.width, exitDoor.height);

                // Door handle
                ctx.beginPath();
                ctx.arc(x + 30, exitDoor.y + 35, 4, 0, Math.PI * 2);
                ctx.fillStyle = isOpen ? '#ffff00' : '#888888';
                ctx.fill();

                // Exit text
                if (isOpen) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXIT', x + exitDoor.width / 2, exitDoor.y - 10);
                }
            }

            // Draw particles
            drawParticles();

            // Draw ball
            const ballX = ball.x - cameraX;

            // Ball shadow
            ctx.beginPath();
            ctx.ellipse(ballX, ball.y + ball.radius - 5, ball.radius * 0.8, ball.radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();

            // Ball body
            const gradient = ctx.createRadialGradient(
                ballX - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                ballX, ball.y, ball.radius
            );
            gradient.addColorStop(0, ball.inflated ? '#ff8888' : '#8888ff');
            gradient.addColorStop(1, ball.inflated ? '#cc0000' : '#0000cc');

            ctx.beginPath();
            ctx.arc(ballX, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Ball highlight
            ctx.beginPath();
            ctx.arc(ballX - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fill();

            // Ball outline
            ctx.beginPath();
            ctx.arc(ballX, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.strokeStyle = ball.inflated ? '#aa0000' : '#0000aa';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Game over screens
            if (gameState === 'lost') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);

                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.fillText('Press R to Restart', canvas.width / 2, canvas.height / 2 + 30);
            }

            if (gameState === 'won') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2 - 30);

                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.fillText('Congratulations! Press R to Play Again', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.up = true;
            if (e.key === 'r' || e.key === 'R') {
                currentLevel = 1;
                lives = 3;
                gameState = 'playing';
                loadLevel(currentLevel);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.up = false;
        });

        // Mobile controls
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        const btnJump = document.getElementById('btnJump');

        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
        btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); keys.left = false; });
        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; });
        btnRight.addEventListener('touchend', (e) => { e.preventDefault(); keys.right = false; });
        btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); keys.up = true; });
        btnJump.addEventListener('touchend', (e) => { e.preventDefault(); keys.up = false; });

        // Start game
        loadLevel(currentLevel);
        gameLoop();
    </script>
</body>

</html>